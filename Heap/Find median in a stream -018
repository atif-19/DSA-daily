/*
Problem:
Find the median of a stream of integers.

Description:
Given an array of integers, for each prefix of the array (from index 0 to i),
compute the median of the elements seen so far.

Approach:
Two Heaps Technique

- Use a Max Heap (LeftmaxHeap) to store the smaller half of numbers
- Use a Min Heap (RightminHeap) to store the larger half of numbers
- Maintain the size difference between heaps to be at most 1
- Max Heap will always have the extra element when total count is odd

Steps:
1. Insert the first element into Max Heap
2. For each new element:
   - Push into appropriate heap based on comparison with Max Heap top
   - Balance the heaps if size difference exceeds 1
3. Median calculation:
   - If both heaps have equal size → average of tops
   - Else → top of Max Heap

Time Complexity:
- Insertion per element: O(log n)
- Total time: O(n log n)

Space Complexity:
- O(n) for storing elements in heaps
*/

class Solution {
  public:
    vector<double> getMedian(vector<int> &arr) {
        priority_queue<int> LeftmaxHeap; 
        priority_queue<int, vector<int>, greater<int>> RightminHeap;

        vector<double> ans(arr.size());

        // First element goes to max heap
        LeftmaxHeap.push(arr[0]);
        ans[0] = LeftmaxHeap.top();

        for (int i = 1; i < arr.size(); i++) {

            // Step 1: Insert element into appropriate heap
            if (arr[i] < LeftmaxHeap.top())
                LeftmaxHeap.push(arr[i]);
            else
                RightminHeap.push(arr[i]);

            // Step 2: Balance the heaps
            if (LeftmaxHeap.size() > RightminHeap.size() + 1) {
                RightminHeap.push(LeftmaxHeap.top());
                LeftmaxHeap.pop();
            }
            else if (RightminHeap.size() > LeftmaxHeap.size()) {
                LeftmaxHeap.push(RightminHeap.top());
                RightminHeap.pop();
            }

            // Step 3: Compute median
            if (LeftmaxHeap.size() == RightminHeap.size()) {
                ans[i] = (LeftmaxHeap.top() + RightminHeap.top()) / 2.0;
            } else {
                ans[i] = LeftmaxHeap.top();
            }
        }

        return ans;
    }
};
