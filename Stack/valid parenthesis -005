/*
ğŸ§© Problem: Valid Parentheses
--------------------------------------------
Given a string `s` containing just the characters 
'(', ')', '{', '}', '[' and ']', determine if the input string is valid.

A string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

--------------------------------------------
ğŸ”¹ Example 1:
Input: s = "()"
Output: true

ğŸ”¹ Example 2:
Input: s = "()[]{}"
Output: true

ğŸ”¹ Example 3:
Input: s = "(]"
Output: false

--------------------------------------------
ğŸ’¡ Approach:
We use a stack to keep track of opening brackets.
- Whenever we encounter an opening bracket, we push it onto the stack.
- For every closing bracket, we check if the top of the stack contains the corresponding opening bracket.
  - If it matches, we pop it.
  - If it doesnâ€™t match or the stack is empty, the string is invalid.
- After processing all characters, if the stack is empty, the string is valid.

--------------------------------------------
â±ï¸ Time Complexity: O(N)
Each character is pushed and popped at most once.

ğŸ’¾ Space Complexity: O(N)
Stack stores at most all the opening brackets.

--------------------------------------------
âœ… Status: Accepted on LeetCode
*/

#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    bool isValid(string s) {
        stack<char> st;

        for (int i = 0; i < s.size(); i++) {
            // Case 1: Stack is empty
            if (st.empty()) {
                if (s[i] == '(' || s[i] == '{' || s[i] == '[')
                    st.push(s[i]);
                else // Closing without an opening
                    return false;
            }

            // Case 2: Opening parenthesis â†’ push it
            else if (s[i] == '(' || s[i] == '{' || s[i] == '[') {
                st.push(s[i]);
            }

            // Case 3: Closing parenthesis â†’ check top of stack
            else {
                if ((s[i] == ')' && st.top() == '(') ||
                    (s[i] == '}' && st.top() == '{') ||
                    (s[i] == ']' && st.top() == '['))
                    st.pop();
                else
                    return false;
            }
        }

        // Valid if no unmatched openings remain
        return st.empty();
    }
};
