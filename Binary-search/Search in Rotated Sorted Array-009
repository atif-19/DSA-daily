/*
LeetCode 33. Search in Rotated Sorted Array
ğŸ”— https://leetcode.com/problems/search-in-rotated-sorted-array/

ğŸ§  Problem Statement:
There is an integer array nums sorted in ascending order (with distinct values),
which is rotated at an unknown pivot index k (e.g. [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given the array nums and an integer target.

Your task: Return the index of target if it is in nums, otherwise return -1.
You must write an algorithm with O(log n) runtime complexity.

ğŸ§ª Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4

ğŸ§ª Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1

ğŸ§ª Example 3:
Input: nums = [1], target = 0
Output: -1

ğŸ”’ Constraints:
- 1 <= nums.length <= 5000
- -10^4 <= nums[i] <= 10^4
- All values of nums are unique
- nums is guaranteed to be rotated at least once
- -10^4 <= target <= 10^4
*/

class Solution {
public:
    int search(vector<int>& nums, int target) {
        int start = 0, end = nums.size() - 1, mid;

        // Binary Search in Rotated Sorted Array
        while (start <= end) {
            mid = start + (end - start) / 2;

            // ğŸ¯ Target found
            if (nums[mid] == target)
                return mid;

            // ğŸ§  Left half is sorted
            if (nums[mid] >= nums[start]) {
                if (target >= nums[start] && target < nums[mid])
                    end = mid - 1;  // ğŸ” Target in left half
                else
                    start = mid + 1;  // â¡ï¸ Move right
            }
            // ğŸ§  Right half is sorted
            else {
                if (target > nums[mid] && target <= nums[end])
                    start = mid + 1;  // ğŸ” Target in right half
                else
                    end = mid - 1;  // â¬…ï¸ Move left
            }
        }

        // ğŸš« Target not found
        return -1;
    }
};
