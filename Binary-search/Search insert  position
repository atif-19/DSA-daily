class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int start = 0, end = nums.size() - 1, mid;

        // Standard Binary Search Loop
        while (start <= end) {
            mid = start + (end - start) / 2;

            if (nums[mid] == target)
                return mid;  // Found target, return its index

            else if (nums[mid] < target)
                start = mid + 1;  // Look right

            else
                end = mid - 1;    // Look left
        }

        // If target not found, return index where it would be inserted
        return start;
    }
};


/*
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ðŸ§  TL;DR for Future Me:

ðŸ” Goal:
    - Return the index of the target if found.
    - Otherwise, return the index where it should be inserted to keep the array sorted.

ðŸ” How it works:
    - Classic binary search.
    - If target found â†’ return index.
    - If not found â†’ 'start' will be at the correct insert position.

â±ï¸ Time Complexity:
    - O(log n) â€” efficient!

ðŸ—ƒï¸ Space Complexity:
    - O(1) â€” no extra memory used.

ðŸ“Œ Edge Cases:
    - Empty array â†’ returns 0
    - Target smaller than all elements â†’ returns 0
    - Target larger than all â†’ returns nums.size()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
*/
