/*
    ğŸ§© Problem: String Permutations (Distinct + Duplicate Characters)
    ---------------------------------------------------------------
    Given a string S (consisting of uppercase letters), generate 
    all possible **unique permutations** of the characters of S.

    Example:
    Input:  S = "AAB"
    Output: ["AAB", "ABA", "BAA"]

    ---------------------------------------------------------------
    ğŸ’¡ Approach: Frequency-Based Backtracking (No Sorting, No Set)
    ---------------------------------------------------------------
    - Instead of generating all permutations and removing duplicates,
      we track how many times each character appears using a frequency array.

    - At each recursive step:
        1ï¸âƒ£ Pick any character whose count > 0
        2ï¸âƒ£ Append it to the current string (temp)
        3ï¸âƒ£ Decrease its count and recurse
        4ï¸âƒ£ Backtrack by removing the character and restoring the count

    - This ensures each unique permutation is generated **once** directly.

    ---------------------------------------------------------------
    ğŸ§  Example Walkthrough:
    S = "AAB"
    count = [A:2, B:1]

    Step 1 â†’ pick 'A' â†’ temp = "A", count[A] = 1
        Step 2 â†’ pick 'A' again â†’ temp = "AA", count[A] = 0
            Step 3 â†’ pick 'B' â†’ temp = "AAB" âœ…
        Backtrack â†’ temp = "A"
        Step 4 â†’ pick 'B' â†’ temp = "AB"
            Step 5 â†’ pick 'A' â†’ temp = "ABA" âœ…
    Backtrack fully â†’ pick 'B' first â†’ temp = "B"
        Step 6 â†’ pick 'A' twice â†’ temp = "BAA" âœ…

    Output = ["AAB", "ABA", "BAA"]

    ---------------------------------------------------------------
    â±ï¸ Time Complexity:  O(n Ã— n!)
        - n! possible unique permutations in the worst case.
        - Each takes O(n) time to be copied into ans.

    ğŸ’¾ Space Complexity: O(n + 26)
        - Recursion depth: O(n)
        - Count array: fixed size (26)
        - Output: O(n Ã— n!) for storing all results.

    ---------------------------------------------------------------
    âœ… This is the optimal and elegant approach for unique string permutations.
*/

class Solution {
public:
    // Recursive function to generate all unique permutations
    void Permut(vector<string>& ans, vector<int>& count, string &temp, string s) {
        // Base case: when all characters are used
        if (temp.size() == s.size()) {
            ans.push_back(temp);
            return;
        }

        // Try placing each available character
        for (int i = 0; i < count.size(); i++) {
            if (count[i] != 0) {
                count[i]--;
                temp += ('A' + i);             // Add corresponding character
                Permut(ans, count, temp, s);   // Recurse
                count[i]++;                    // Backtrack
                temp.pop_back();               // Remove last char
            }
        }
    }

    // Main function
    vector<string> findPermutation(string &s) {
        vector<string> ans;
        string temp = "";
        vector<int> count(26, 0);

        // Fill frequency array for each character
        for (int i = 0; i < s.size(); i++)
            count[s[i] - 'A']++;

        // Generate all unique permutations
        Permut(ans, count, temp, s);
        return ans;
    }
};
