/*
ğŸ’¡ Problem: Tower of Hanoi

Given `n` disks and three rods (source, auxiliary, and destination),
the Tower of Hanoi problem asks you to move all disks from the source rod
to the destination rod under the following rules:
1. Only one disk can be moved at a time.
2. A disk can only be placed on top of a larger disk.
3. You can use the auxiliary rod as temporary storage.

Your task:
Return the total number of moves required to move `n` disks from the
source rod to the destination rod.

---

ğŸ”¢ Example:
Input: n = 3
Output: 7

Explanation:
For 3 disks, the steps are:
1. Move 2 disks from source â†’ auxiliary
2. Move 1 disk from source â†’ destination
3. Move 2 disks from auxiliary â†’ destination
Total moves = 7 (which is 2^n - 1)

---

ğŸ§  Recursive Approach:
- Move (nâˆ’1) disks from source â†’ helper
- Move 1 disk from source â†’ destination
- Move (nâˆ’1) disks from helper â†’ destination

Each recursive call breaks down the problem until n == 1.

---

â±ï¸ Time Complexity:
O(2^n)
â†’ Because each call spawns two more recursive calls until the base case.

ğŸ’¾ Space Complexity:
O(n)
â†’ Due to recursion call stack depth of size `n`.

---

ğŸ§© Implementation:
*/

int toh(int n, int sour, int help, int dest) {
    // Base case: Only one disk â€” just one move required
    if (n == 1) {
        return 1;
    }

    // Recursive case:
    // Move (n-1) disks from source â†’ helper using destination as temporary
    // Move 1 disk from source â†’ destination
    // Move (n-1) disks from helper â†’ destination using source as temporary
    return toh(n - 1, sour, dest, help) + toh(n - 1, help, sour, dest) + 1;
}

// Wrapper function for Tower of Hanoi
int towerOfHanoi(int n, int from, int to, int aux) {
    int ans = toh(n, from, aux, to);
    return ans;
}

/*
âœ… Final Notes:
For n disks, total moves required = (2^n) - 1
You can test this function like:
cout << towerOfHanoi(3, 1, 3, 2);  // Output: 7
*/
