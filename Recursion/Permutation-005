/*
    üß© Problem: Permutations (LeetCode #46)
    -----------------------------------------------------
    Given an array nums of distinct integers, return all 
    possible permutations of the array. You may return 
    the answer in any order.

    Example:
    Input: nums = [1,2,3]
    Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

    -----------------------------------------------------
    üí° Approach: Backtracking using In-Place Swapping
    -----------------------------------------------------
    - We generate all permutations by fixing one element 
      at each recursion level and recursively permuting 
      the remaining ones.
    - For each index, we try placing every unfixed element 
      at that index by swapping.
    - After recursion, we backtrack (swap back) to restore 
      the array for the next iteration.
    
    This avoids extra space for "used" arrays or hash sets.
    It's one of the cleanest and most efficient ways to 
    generate permutations when all elements are distinct.
    
    -----------------------------------------------------
    üß† Example Walkthrough:
    -----------------------------------------------------
    nums = [1, 2, 3]

    index = 0 ‚Üí swap(0,0): [1,2,3]
                   ‚Üí recurse index=1
                       swap(1,1): [1,2,3]
                       swap(1,2): [1,3,2]
               swap(0,1): [2,1,3]
                   ‚Üí recurse index=1 ...
               swap(0,2): [3,2,1]
                   ‚Üí recurse index=1 ...
    
    All permutations generated:
    [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

    -----------------------------------------------------
    ‚è±Ô∏è Time Complexity:  O(n √ó n!)
        - There are n! total permutations.
        - Each permutation requires O(n) time to be stored.

    üíæ Space Complexity: O(n √ó n!)
        - Recursion stack: O(n)
        - Output storage: O(n √ó n!)

    -----------------------------------------------------
    ‚úÖ This is an optimal and elegant backtracking solution.
*/

class Solution {
public:
    // Recursive function to generate all permutations
    void Permut(vector<vector<int>>& ans, int index, vector<int> nums) {
        // Base case: all elements are fixed ‚Üí store current permutation
        if (index >= nums.size()) {
            ans.push_back(nums);
            return;
        }

        // Try fixing each element at the current position
        for (int i = index; i < nums.size(); i++) {
            swap(nums[i], nums[index]);       // Fix element at 'index'
            Permut(ans, index + 1, nums);     // Recurse for next position
            swap(nums[i], nums[index]);       // Backtrack (undo the swap)
        }
    }

    // Main function to return all permutations
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> ans;
        Permut(ans, 0, nums);
        return ans;
    }
};
