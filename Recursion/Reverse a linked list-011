/**
 * ðŸš€ Problem: Reverse a Singly Linked List (Recursive Approach)
 *
 * ðŸ§  Intuition:
 * We recursively reverse the linked list by:
 * 1ï¸âƒ£ Storing the next node (fut).
 * 2ï¸âƒ£ Reversing the current nodeâ€™s pointer to point backward (curr->next = prev).
 * 3ï¸âƒ£ Moving one step ahead (curr = fut).
 * 4ï¸âƒ£ When curr becomes NULL, we return prev (which becomes the new head).
 *
 * ðŸ§© Example:
 * Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ NULL
 * Output: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL
 *
 * âš™ï¸ Time Complexity: O(n)
 * ðŸ’¾ Space Complexity: O(n) â€” due to recursion call stack
 *
 * âš”ï¸ Comparison:
 * - Recursive â†’ Elegant, readable, conceptually clear.
 * - Iterative â†’ More memory-efficient (O(1)), better for very large lists.
 */

struct ListNode {
    int val;
    ListNode *next;

    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    // Recursive helper function to reverse the list
    ListNode* rev(ListNode* curr, ListNode* prev) {
        // Base case: when we reach the end of the list
        if (curr == nullptr)
            return prev;

        // Store the next node
        ListNode* fut = curr->next;

        // Reverse the link
        curr->next = prev;

        // Recursive call for the rest of the list
        return rev(fut, curr);
    }

    // Main function to reverse the entire linked list
    ListNode* reverseList(ListNode* head) {
        return rev(head, nullptr);
    }
};
