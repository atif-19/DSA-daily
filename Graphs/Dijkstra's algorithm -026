class Solution {
  public:

    /*
        Function: dijkstra
        --------------------------------------------------
        Finds shortest distance from source node to all
        other nodes in an undirected weighted graph using
        Dijkstra's Algorithm (Min-Heap based).

        Parameters:
        V     -> Number of vertices
        edges -> Edge list where each entry is {u, v, w}
        src   -> Source vertex

        Returns:
        A vector dist[] where dist[i] is the shortest
        distance from src to node i.

        Time Complexity:
        O((V + E) * log V)

        Space Complexity:
        O(V + E)
    */

    vector<int> dijkstra(int V, vector<vector<int>> &edges, int src) {

        // Step 1: Build adjacency list
        // adjList[u] contains {v, weight}
        vector<vector<pair<int,int>>> adjList(V);

        for(int i = 0; i < edges.size(); i++){
            int u = edges[i][0];
            int v = edges[i][1];
            int weight = edges[i][2];

            // Undirected graph
            adjList[u].push_back({v, weight});
            adjList[v].push_back({u, weight});
        }

        // Step 2: Distance array
        // Initialize all distances as infinite
        vector<int> dist(V, INT_MAX);
        dist[src] = 0;

        // Step 3: Min-Heap Priority Queue
        // Stores {distance, node}
        priority_queue<
            pair<int,int>,
            vector<pair<int,int>>,
            greater<pair<int,int>>
        > pq;

        pq.push({0, src});

        // Step 4: Dijkstra traversal
        while(!pq.empty()) {

            // Extract node with smallest distance
            int node = pq.top().second;
            int currDist = pq.top().first;
            pq.pop();

            // Ignore outdated heap entries
            if(currDist > dist[node])
                continue;

            // Step 5: Relax neighbors
            for(int i = 0; i < adjList[node].size(); i++) {

                int neighbor = adjList[node][i].first;
                int weight   = adjList[node][i].second;

                // If shorter path found
                if(dist[neighbor] > dist[node] + weight) {

                    dist[neighbor] = dist[node] + weight;

                    // Push updated distance
                    pq.push({dist[neighbor], neighbor});
                }
            }
        }

        // Step 6: Return shortest distances
        return dist;
    }
};
