// User function Template for C++
//
// PROBLEM:
// Given an array of strings, check whether they can be arranged
// such that the last character of a string is the first character
// of the next string, forming a complete circle.
//
// APPROACH:
// This is an Eulerian Cycle problem on a directed graph.
//
// 1. Treat each character ('a' to 'z') as a node.
// 2. For each string:
//    - Create a directed edge from first character to last character.
//    - Increase indegree of first character.
//    - Increase outdegree of last character.
// 3. For a valid circle:
//    - Indegree must be equal to outdegree for every node.
//    - All nodes with non-zero degree must be in a single connected component.
// 4. Use DFS to check connectivity starting from any node
//    with non-zero degree.
//
// TIME COMPLEXITY:
// O(N + 26) ≈ O(N)
// where N = number of strings
//
// SPACE COMPLEXITY:
// O(26 + N) ≈ O(N)
// for adjacency list, visited array, indegree & outdegree arrays

class Solution {
  public:
    // DFS to check connectivity of graph
    void DFS(int node, vector<vector<int>>& adj, vector<int>& visited) {
        visited[node] = 1;
        for (int i = 0; i < adj[node].size(); i++) {
            int neighbor = adj[node][i];
            if (!visited[neighbor]) {
                DFS(neighbor, adj, visited);
            }
        }
    }

    int isCircle(vector<string> &arr) {
        // indegree and outdegree for each character
        vector<int> indegree(26, 0);
        vector<int> outdegree(26, 0);

        // adjacency list for graph
        vector<vector<int>> adj(26);

        // build graph
        for (int i = 0; i < arr.size(); i++) {
            string s = arr[i];
            int first = s[0] - 'a';
            int last = s[s.size() - 1] - 'a';

            adj[first].push_back(last);
            indegree[first]++;
            outdegree[last]++;
        }

        // check indegree == outdegree for every node
        int startNode = -1;
        for (int i = 0; i < 26; i++) {
            if (indegree[i] != outdegree[i]) {
                return 0;
            }
            if (indegree[i] > 0 && startNode == -1) {
                startNode = i;
            }
        }

        // if no edges exist, circle is possible
        if (startNode == -1) return 1;

        // check if all non-zero degree nodes are connected
        vector<int> visited(26, 0);
        DFS(startNode, adj, visited);

        for (int i = 0; i < 26; i++) {
            if (indegree[i] > 0 && !visited[i]) {
                return 0;
            }
        }

        return 1;
    }
};
