/*
Problem:
---------
Breadth First Search (BFS) of a Graph

Given an adjacency list representation of an undirected graph,
perform Breadth First Search (BFS) starting from node 0
and return the order of traversal.


Approach:
---------
Breadth First Search (BFS)

1. Use a queue to explore nodes level by level.
2. Start BFS from node 0.
3. Maintain a visited structure to ensure each node
   is processed only once.
4. Push the starting node into the queue and mark it as visited.
5. While the queue is not empty:
   - Pop the front node.
   - Visit all its unvisited neighbors.
   - Mark them as visited and push them into the queue.
6. Store the traversal order in a result vector.


Time Complexity:
----------------
O(V + E)
V = number of vertices
E = number of edges
Each vertex and edge is visited once.


Space Complexity:
-----------------
O(V)
Used for the queue, visited map, and result array.
*/

class Solution {
public:
    vector<int> bfs(vector<vector<int>> &adj) {

        queue<int> q;                    // queue for BFS
        unordered_map<int, bool> mp;     // visited map
        vector<int> ans;                 // stores BFS traversal

        // start BFS from node 0
        q.push(0);
        mp[0] = true;
        ans.push_back(0);

        while (!q.empty()) {
            int index = q.front();
            q.pop();

            // visit all adjacent nodes
            for (int i = 0; i < adj[index].size(); i++) {
                if (!mp[adj[index][i]]) {
                    q.push(adj[index][i]);
                    mp[adj[index][i]] = true;
                    ans.push_back(adj[index][i]);
                }
            }
        }

        return ans;
    }
};
