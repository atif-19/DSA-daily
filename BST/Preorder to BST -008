/*
ğŸ“Œ Question:
Given an array representing the preorder traversal of a Binary Search Tree (BST),
construct and return the BST.

------------------------------------------------------------

ğŸ§  Approach (Optimal O(N) Solution):
This solution uses the properties of:
- Preorder traversal (Root â†’ Left â†’ Right)
- BST value constraints (left < root < right)

Key ideas:
1. Use a single index to track the current element in preorder.
2. Maintain a valid value range [lower, upper] for each subtree.
3. If the current value lies outside this range, it cannot be placed here.
4. Create the node and recursively build:
   - Left subtree with range [lower, node->val]
   - Right subtree with range [node->val, upper]

Each element is processed exactly once, making this optimal.

------------------------------------------------------------

ğŸ” Analogy:
Imagine placing numbers into a BST while walking through preorder:
- Each number is allowed only within certain boundaries.
- If it doesnâ€™t fit the range, you skip it for this subtree.
- This guarantees correct placement without searching.

Itâ€™s like assigning seats ğŸŸï¸ where each seat has strict entry limits.

------------------------------------------------------------

â±ï¸ Time Complexity:
- O(N), where N is the number of nodes
- Each element is visited once

------------------------------------------------------------

ğŸ’¾ Space Complexity:
- O(H), where H is the height of the tree
- Due to recursive call stack
- Worst Case: O(N) (skewed BST)
- Average Case: O(log N)

------------------------------------------------------------
*/

class Solution {
public:
    TreeNode* BST(vector<int>& preorder, int &index, int lower, int upper) {
        if (index == preorder.size() || 
            preorder[index] < lower || 
            preorder[index] > upper)
            return NULL;

        TreeNode* n = new TreeNode(preorder[index++]);
        n->left = BST(preorder, index, lower, n->val);
        n->right = BST(preorder, index, n->val, upper);

        return n;
    }

    TreeNode* bstFromPreorder(vector<int>& preorder) {
        int index = 0;
        return BST(preorder, index, INT_MIN, INT_MAX);
    }
};
