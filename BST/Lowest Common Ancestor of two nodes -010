/*
ðŸ“Œ Question:
Given a Binary Search Tree (BST) and two nodes n1 and n2,
find their Lowest Common Ancestor (LCA).

The Lowest Common Ancestor is defined as the lowest node
in the tree that has both n1 and n2 as descendants
(allowing a node to be a descendant of itself).

------------------------------------------------------------

ðŸ§  Approach (Using BST Property â€“ Optimal):
A Binary Search Tree has the following property:
- Left subtree contains smaller values
- Right subtree contains larger values

At any node:
1. If both n1 and n2 are smaller than the current node,
   move to the left subtree.
2. If both n1 and n2 are greater than the current node,
   move to the right subtree.
3. Otherwise (values split or one matches the current node),
   the current node is the Lowest Common Ancestor.

This approach avoids unnecessary traversal.

------------------------------------------------------------

ðŸ” Analogy:
Think of finding the last common junction on two GPS routes ðŸ—ºï¸:
- If both routes go left, keep moving left.
- If both go right, keep moving right.
- When they split, that junction is the LCA.

------------------------------------------------------------

â±ï¸ Time Complexity:
- O(H), where H is the height of the BST
- Best/Average Case: O(log N)
- Worst Case: O(N) (skewed BST)

------------------------------------------------------------

ðŸ’¾ Space Complexity:
- O(1)
- Iterative solution uses constant extra space

------------------------------------------------------------
*/

class Solution {
  public:
    Node* LCA(Node* root, Node* n1, Node* n2) {
        Node* curr = root;

        while (curr) {
            if (curr->data < n1->data && curr->data < n2->data) {
                curr = curr->right;
            }
            else if (curr->data > n1->data && curr->data > n2->data) {
                curr = curr->left;
            }
            else {
                return curr;  // Split point or one node equals current
            }
        }
        return NULL;
    }
};
