/*
---------------------------------------------------------
Merge Two BSTs into a Sorted List
---------------------------------------------------------

Approach:
1. Perform inorder traversal on both BSTs.
   - Inorder traversal of a BST gives a sorted sequence.
2. Store the inorder results of both trees in two arrays.
3. Merge the two sorted arrays using the two-pointer technique.

Key Idea:
- Since both inorder traversals are already sorted,
  merging them is similar to merging two sorted arrays.

Time Complexity:
- O(n1 + n2)
  where n1 and n2 are the number of nodes in both BSTs.

Space Complexity:
- O(n1 + n2)
  for storing inorder traversals and the merged result.
---------------------------------------------------------
*/

class Solution {
  public:
    // Inorder traversal to store sorted values of BST
    void inorder(Node* root, vector<int>& ans) {
        if (!root) return;
        inorder(root->left, ans);
        ans.push_back(root->data);
        inorder(root->right, ans);
    }

    // Function to merge two BSTs into a sorted list
    vector<int> merge(Node* root1, Node* root2) {
        vector<int> ans, ans1, ans2;

        // Get inorder traversal of both BSTs
        inorder(root1, ans1);
        inorder(root2, ans2);

        // Merge two sorted arrays
        int i = 0, j = 0;
        while (i < ans1.size() && j < ans2.size()) {
            if (ans1[i] < ans2[j]) {
                ans.push_back(ans1[i++]);
            } else if (ans2[j] < ans1[i]) {
                ans.push_back(ans2[j++]);
            } else {
                // Equal elements from both trees
                ans.push_back(ans1[i]);
                ans.push_back(ans2[j]);
                i++;
                j++;
            }
        }

        // Add remaining elements
        while (i < ans1.size()) ans.push_back(ans1[i++]);
        while (j < ans2.size()) ans.push_back(ans2[j++]);

        return ans;
    }
};
