/*
---------------------------------------------------------------------
üß© Problem: Sliding Window Maximum
---------------------------------------------------------------------

Given an array `nums` and an integer `k`, return the maximum element
in every contiguous subarray (window) of size `k`.

Example:
Input:  nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

---------------------------------------------------------------------
üí° Approach: Monotonic Deque (Optimal O(n) Solution)
---------------------------------------------------------------------

We use a **deque** that stores indexes of elements in decreasing order
of their values. For every index `i`:

1Ô∏è‚É£ **Remove out-of-window elements**  
    If deque.front() <= i - k, pop it.

2Ô∏è‚É£ **Maintain decreasing order**  
    Pop from back while nums[d.back()] < nums[i].

3Ô∏è‚É£ **Push current index**  
    Now deque.front() holds the index of maximum for current window.

4Ô∏è‚É£ **Record answer**  
    Once we reach i >= k-1, append nums[d.front()] to result.

This ensures each element is pushed and popped at most once ‚Üí **O(n)**.

---------------------------------------------------------------------
‚è± Time Complexity:  O(n)
üíæ Space Complexity: O(k)
---------------------------------------------------------------------
*/

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> d;        // stores indexes in decreasing order
        vector<int> ans;

        // Preprocess first k-1 elements
        for (int i = 0; i < k - 1; i++) {
            while (!d.empty() && nums[d.back()] < nums[i])
                d.pop_back();
            d.push_back(i);
        }

        // Process full windows
        for (int i = k - 1; i < nums.size(); i++) {

            // 1. Remove out-of-window indexes
            while (!d.empty() && d.front() <= i - k)
                d.pop_front();

            // 2. Maintain decreasing order in deque
            while (!d.empty() && nums[d.back()] < nums[i])
                d.pop_back();

            // 3. Add current index
            d.push_back(i);

            // 4. Max of current window
            ans.push_back(nums[d.front()]);
        }

        return ans;
    }
};
