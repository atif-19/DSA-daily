/*
------------------------------------------------------------
üß© Problem: First Negative Integer in Every Window of Size K
------------------------------------------------------------

Given an array `arr[]` of integers and an integer `k`,
find the first negative integer for every window/subarray 
of size `k`.

If a window does NOT contain any negative element,
return `0` for that window.

------------------------------------------------------------
üí° Approach: Sliding Window + Queue
------------------------------------------------------------

1. Use a queue to store the INDEXES of negative numbers 
   present in the current window.

2. Preprocess the first (k - 1) elements.

3. Slide the window from index (k - 1) to the end:
   - Add current element‚Äôs index if it is negative.
   - Remove elements from front of queue if they fall 
     outside the current window.
   - The front of queue gives the first negative number.

4. If queue is empty ‚Üí push 0 (no negative in this window).

------------------------------------------------------------
‚è± Time Complexity:  O(n)
   - Each index is pushed and popped at most once.

üíæ Space Complexity: O(k)
   - Queue stores indexes from the current window.

------------------------------------------------------------
*/

class Solution {
public:
    vector<int> firstNegInt(vector<int>& arr, int k) {
        queue<int> q;          // stores indexes of negative numbers
        vector<int> ans;

        // Step 1: Preprocess first k-1 elements
        for(int i = 0; i < k - 1; i++) {
            if(arr[i] < 0)
                q.push(i);
        }

        // Step 2: Process each window
        for(int i = k - 1; i < arr.size(); i++) {

            // Add current element if negative
            if(arr[i] < 0)
                q.push(i);

            // Remove elements out of the current window
            while(!q.empty() && q.front() <= i - k)
                q.pop();

            // Add answer for this window
            if(q.empty())
                ans.push_back(0);
            else
                ans.push_back(arr[q.front()]);
        }

        return ans;
    }
};
