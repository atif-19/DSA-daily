/*
    TOP VIEW OF BINARY TREE — DFS + HORIZONTAL DISTANCE

    This implementation finds the Top View of a binary tree using:
    1. DFS traversal
    2. Horizontal Distance (HD) mapping
    3. Level tracking to ensure only the highest (closest to root) 
       node at each HD is taken.

    ---------------------------------------------------------------
    APPROACH
    ---------------------------------------------------------------

    ✔ Step 1: Determine Leftmost & Rightmost Horizontal Distances
       - We first run `find()` to compute:
            l = min horizontal distance
            r = max horizontal distance
       This helps in creating a fixed-size array for answers.

    ✔ Step 2: Use DFS to Traverse the Tree
       - Perform DFS with:
            pos  -> horizontal distance of current node
            lev  -> depth (root = level 0)
       - At each HD (pos), store the node that appears at the 
         smallest depth (i.e., top-most node).

    ✔ Step 3: Maintain a "level" Array
       - `level[pos]` stores the minimum level visited so far at 
         that horizontal distance.
       - If current level is smaller than stored level → update.

    ✔ Step 4: Final Answer
       - `ans[]` contains the top view nodes from left to right.

    ---------------------------------------------------------------
    TIME COMPLEXITY
       O(N)   — Full DFS + distance calculation
    SPACE COMPLEXITY
       O(W)   — Width of tree (number of HDs)
    ---------------------------------------------------------------

    This method avoids unordered_maps and ensures a cache-friendly,
    index-based approach suitable for competitive programming.
*/

/*
class Node {
  public:
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = nullptr;
        right = nullptr;
    }
};
*/

class Solution {
  public:
    void find(Node* root,int pos,int &l,int&r){
        if(root==NULL)
        return;
        
        l = min(pos,l);
        r = max(pos,r);
        
        find(root->left,pos-1,l,r);
        find(root->right,pos+1,l,r);
    }
    void Tview(Node* root,int pos,int lev,vector<int>&level,vector<int>&ans){
        if(root==NULL)
        return;
        
        if(level[pos]>lev){
            ans[pos]=root->data;
            level[pos]=lev;
        }
        
        Tview(root->left,pos-1,lev+1,level,ans);
        Tview(root->right,pos+1,lev+1,level,ans);
    }
    vector<int> topView(Node *root) {
        int l=0,r=0;
        //finding the left most node & right most node
        find(root,0,l,r);
        vector<int>ans(r-l+1);
        vector<int>level(r-l+1,INT_MAX);
        l  *=-1;
        Tview(root,l,0,level,ans);
        return ans;
    }
};

