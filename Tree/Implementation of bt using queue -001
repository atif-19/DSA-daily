// -------------------------------------------------------------
// Implementation of a Binary Tree using Level-Order Insertion
// (Building a tree by taking user input using a queue-based BFS)
// -------------------------------------------------------------

#include <iostream>
#include <queue>
using namespace std;

// Node structure for the binary tree
class Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int x) {
        data = x;
        left = right = NULL;
    }
};

int main() {
    queue<Node*> q;

    // Start by creating the root of the tree
    Node* root = new Node(1);       // Root initialized with value 1
    q.push(root);

    int first, second;

    // Build the tree level-by-level using BFS
    while (!q.empty()) {
        Node* temp = q.front();
        q.pop();

        // Asking for the left child
        cout << "Insert left child of " << temp->data 
             << " (-1 if none): ";
        cin >> first;

        if (first != -1) {
            Node* n = new Node(first);
            temp->left = n;
            q.push(n);              // Push left child into queue for future expansion
        }

        // Asking for the right child
        cout << "Insert right child of " << temp->data 
             << " (-1 if none): ";
        cin >> second;

        if (second != -1) {
            Node* n = new Node(second);
            temp->right = n;
            q.push(n);              // Push right child into queue for future expansion
        }
    }

    return 0;
}
