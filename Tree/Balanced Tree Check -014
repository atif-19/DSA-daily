/*
    Definition for Binary Tree Node:
    --------------------------------
    class Node {
      public:
        int data;
        Node* left;
        Node* right;

        Node(int val) {
            data = val;
            left = NULL;
            right = NULL;
        }
    };
*/

/*
    Problem:
    --------
    Determine whether a binary tree is **height-balanced**.

    A tree is height-balanced if:
        |height(left subtree) - height(right subtree)| ≤ 1
    for every node in the tree.

    Approach:
    ---------
    We use a post-order traversal (Left → Right → Node) to compute:
        - Height of each subtree
        - Whether the subtree is balanced

    Function `height(root, valid)` returns:
        → Height of the current subtree
    and updates:
        → `valid = 0` if any node violates the balance condition.

    Why an extra variable?
    ----------------------
    This prevents repeated checks and makes the algorithm O(n).
    Without it, we'd recompute heights repeatedly → O(n²).

    Steps:
    ------
    1. Recursively compute left and right subtree heights.
    2. Check if their difference > 1.
    3. If yes → mark the tree as not balanced.
    4. Return height = 1 + max(left, right).

    Time Complexity:
    ----------------
    O(n) — each node is visited once.

    Space Complexity:
    -----------------
    O(h) — recursion stack height (h = height of tree).
*/

class Solution {
  public:
    // Returns height of subtree and updates 'valid' if unbalanced
    int height(Node* root, int &valid) {
        if (root == NULL)
            return 0;

        int L = height(root->left, valid);
        int R = height(root->right, valid);

        if (abs(L - R) > 1)
            valid = 0;

        return 1 + max(L, R);
    }

    // Checks if the binary tree is height-balanced
    bool isBalanced(Node* root) {
        int valid = 1;
        height(root, valid);
        return valid;
    }
};
