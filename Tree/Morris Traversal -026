// ============================================================================
// Morris Traversal (Inorder, Preorder, Postorder)
// ============================================================================
// Key Idea:
// ---------
// Morris Traversal allows tree traversal with:
// ‚úÖ O(n) Time Complexity
// ‚úÖ O(1) Extra Space (no recursion, no stack)
//
// It works by temporarily modifying the tree using "threads"
// and restoring it back after traversal.
//
// Tree Node Structure:
// --------------------
/*
struct Node {
    int data;
    Node* left;
    Node* right;
};
*/
// ============================================================================

class Solution {
  public:

    // ========================================================================
    // 1Ô∏è‚É£ MORRIS INORDER TRAVERSAL (Left ‚Üí Root ‚Üí Right)
    // ========================================================================
    vector<int> inOrder(Node* root) {
        Node* curr = root;
        vector<int> ans;

        while (curr) {
            // If left subtree exists
            if (curr->left) {
                // Find the rightmost node of left subtree
                Node* temp = curr->left;
                while (temp->right && temp->right != curr)
                    temp = temp->right;

                // If thread already exists ‚Üí break it and visit current
                if (temp->right) {
                    temp->right = NULL;
                    ans.push_back(curr->data);
                    curr = curr->right;
                }
                // Create thread and move left
                else {
                    temp->right = curr;
                    curr = curr->left;
                }
            }
            // If no left subtree, visit and move right
            else {
                ans.push_back(curr->data);
                curr = curr->right;
            }
        }
        return ans;
    }

    // ========================================================================
    // 2Ô∏è‚É£ MORRIS PREORDER TRAVERSAL (Root ‚Üí Left ‚Üí Right)
    // ========================================================================
    vector<int> preOrder(Node* root) {
        Node* curr = root;
        vector<int> ans;

        while (curr) {
            // If left subtree exists
            if (curr->left) {
                // Find the rightmost node of left subtree
                Node* temp = curr->left;
                while (temp->right && temp->right != curr)
                    temp = temp->right;

                // If thread already exists ‚Üí break it
                if (temp->right) {
                    temp->right = NULL;
                    curr = curr->right;
                }
                // First time visiting node ‚Üí record it
                else {
                    ans.push_back(curr->data);
                    temp->right = curr;
                    curr = curr->left;
                }
            }
            // If no left subtree, visit and move right
            else {
                ans.push_back(curr->data);
                curr = curr->right;
            }
        }
        return ans;
    }

    // ========================================================================
    // 3Ô∏è‚É£ MORRIS POSTORDER TRAVERSAL (Left ‚Üí Right ‚Üí Root)
    // ========================================================================
    vector<int> postOrder(Node* root) {
        Node* curr = root;
        vector<int> ans;

        while (curr) {
            // If right subtree exists
            if (curr->right) {
                // Find the leftmost node of right subtree
                Node* temp = curr->right;
                while (temp->left && temp->left != curr)
                    temp = temp->left;

                // If thread already exists ‚Üí break it
                if (temp->left) {
                    temp->left = NULL;
                    curr = curr->left;
                }
                // First time visiting node ‚Üí record it
                else {
                    ans.push_back(curr->data);
                    temp->left = curr;
                    curr = curr->right;
                }
            }
            // If no right subtree
            else {
                ans.push_back(curr->data);
                curr = curr->left;
            }
        }

        // Reverse result because traversal is Root ‚Üí Right ‚Üí Left
        reverse(ans.begin(), ans.end());
        return ans;
    }
};

// ============================================================================
// Summary:
// --------
// Inorder   ‚Üí Morris with left subtree threading
// Preorder  ‚Üí Record node before creating thread
// Postorder ‚Üí Reverse modified traversal (NRL ‚Üí LRN)
//
// Perfect for interviews & space-optimized tree traversal questions üöÄ
// ============================================================================
