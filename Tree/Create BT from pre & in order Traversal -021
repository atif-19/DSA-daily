/*
    ----------------------------------------------------
    Build Binary Tree from Inorder + Preorder Traversal
    ----------------------------------------------------

    Given two arrays:
      - inorder[]   → Left, Root, Right
      - preorder[]  → Root, Left, Right

    We reconstruct the unique binary tree that produces
    these traversal sequences.

    Key Insight:
    ---------------------------------------------------
    In preorder, the FIRST element is always the root.
    Once the root is found in inorder[], everything
    left of it is the left subtree, and everything
    right of it is the right subtree.
    ---------------------------------------------------
*/

class Solution {
  public:

    /*
        Find the index of `target` in inorder[]
        within the given range [start, end].

        Time: O(n) per search (can be optimized using a map)
    */
    int find(vector<int> &inorder, int start, int end, int target) {
        for (int i = start; i <= end; i++) {
            if (inorder[i] == target)
                return i;
        }
        return -1;
    }

    /*
        Recursively builds the tree from:

        - inorder:  [Left | Root | Right]
        - preorder: [Root | Left | Right]

        Parameters:
            inorder   → inorder traversal
            preorder  → preorder traversal
            InStart   → start index in inorder[]
            InEnd     → end index in inorder[]
            index     → current index in preorder[] (current root)

        Returns:
            Pointer to the constructed subtree root.
    */
    Node* Tree(vector<int> &inorder, vector<int> &preorder,
               int InStart, int InEnd, int index) {

        // Base case: no nodes left to process
        if (InStart > InEnd)
            return NULL;

        // Current node (root of this subtree)
        Node* temp = new Node(preorder[index]);

        // Locate root in inorder[] to split left/right subtree
        int pos = find(inorder, InStart, InEnd, preorder[index]);

        /*
            preorder format:
                Root | Left Subtree | Right Subtree

            Left subtree root:
                index + 1

            Right subtree root:
                index + (size_of_left_subtree) + 1
                where size_of_left_subtree = pos - InStart
        */

        // Build left subtree
        temp->left = Tree(inorder, preorder,
                          InStart, pos - 1,
                          index + 1);

        // Build right subtree
        temp->right = Tree(inorder, preorder,
                           pos + 1, InEnd,
                           index + (pos - InStart) + 1);

        return temp;
    }

    /*
        Main function to build the full tree.
        Starts with:
            - complete inorder range
            - preorder[0] as the root
    */
    Node* buildTree(vector<int> &inorder, vector<int> &preorder) {
        return Tree(inorder, preorder,
                    0, inorder.size() - 1,
                    0);
    }
};
