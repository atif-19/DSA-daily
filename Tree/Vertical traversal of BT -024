/*
================================================================================
Vertical Order Traversal of a Binary Tree
================================================================================

Problem:
---------
Given a binary tree, perform a vertical order traversal.
Nodes that lie on the same vertical line (same horizontal distance from root)
should be grouped together.

Vertical order rules:
- Traverse from leftmost vertical line to rightmost
- Nodes in the same vertical line must appear from top to bottom
- If multiple nodes are on the same level and vertical line, they appear
  in left-to-right order

--------------------------------------------------------------------------------
Approach:
---------
1. First, determine the minimum and maximum horizontal distance (HD) of the tree.
   - Root has HD = 0
   - Left child  -> HD - 1
   - Right child -> HD + 1

2. Using the HD range, create a result vector of required size.

3. Perform a level-order traversal (BFS) while tracking horizontal distance:
   - Use a queue for nodes
   - Use another queue to store corresponding HD indices
   - Map each node to its correct vertical index and push it into result

--------------------------------------------------------------------------------
Why BFS?
--------
Level-order traversal ensures:
- Top-to-bottom ordering
- Left-to-right ordering for nodes at the same level

--------------------------------------------------------------------------------
Time Complexity:
----------------
O(n)  -> Each node is visited once

Space Complexity:
-----------------
O(n)  -> Queue + result storage

--------------------------------------------------------------------------------
*/

class Solution {
  public:
    
    // Helper function to find leftmost and rightmost horizontal distances
    void find(Node* root, int pos, int &l, int &r) {
        if (root == NULL) return;
        
        l = min(l, pos);
        r = max(r, pos);
        
        find(root->left, pos - 1, l, r);
        find(root->right, pos + 1, l, r);
    }
    
    // Function to return vertical order traversal
    vector<vector<int>> verticalOrder(Node *root) {
        // Step 1: Find horizontal distance range
        int l = 0, r = 0;
        find(root, 0, l, r);
        
        // Step 2: Prepare result container
        vector<vector<int>> ans(r - l + 1);
        
        // Step 3: Level order traversal with horizontal distance tracking
        queue<Node*> q;
        queue<int> axis;
        
        q.push(root);
        axis.push(-l);   // Shift index so that leftmost starts at 0
        
        while (!q.empty()) {
            Node* temp = q.front();
            q.pop();
            int a = axis.front();
            axis.pop();
            
            // Add current node to its vertical line
            ans[a].push_back(temp->data);
            
            // Process left child
            if (temp->left) {
                q.push(temp->left);
                axis.push(a - 1);
            }
            
            // Process right child
            if (temp->right) {
                q.push(temp->right);
                axis.push(a + 1);
            }
        }
        
        return ans;
    }
};
