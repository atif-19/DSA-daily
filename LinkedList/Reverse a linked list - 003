/**
 * ğŸš€ Problem: Reverse a Singly Linked List (Iterative Approach)
 *
 * ğŸ§  Intuition:
 * The idea is to reverse the `next` pointers of each node one by one
 * using three pointers: `prev`, `curr`, and `prec` (next node).
 *
 * ğŸª„ Step-by-step:
 * 1ï¸âƒ£ Initialize `prev = NULL` (for new tail) and `curr = head` (for traversal).
 * 2ï¸âƒ£ Store the next node as `prec = curr->next` before breaking the link.
 * 3ï¸âƒ£ Reverse the current nodeâ€™s pointer: `curr->next = prev`.
 * 4ï¸âƒ£ Move both `prev` and `curr` one step forward.
 * 5ï¸âƒ£ When `curr` becomes NULL, `prev` points to the new head.
 *
 * ğŸ§© Example:
 * Input:  1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ NULL
 * Output: 5 â†’ 4 â†’ 3 â†’ 2 â†’ 1 â†’ NULL
 *
 * âš™ï¸ Time Complexity: O(n)
 * ğŸ’¾ Space Complexity: O(1)
 *
 * âš”ï¸ Comparison:
 * - Iterative â†’ Faster, constant space, production-friendly.
 * - Recursive â†’ Cleaner, conceptual clarity, but uses O(n) stack space.
 */

struct ListNode {
    int val;
    ListNode *next;

    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr; // Previous node
        ListNode* prec = nullptr; // Next node (to preserve before breaking link)
        ListNode* curr = head;    // Current node

        // Traverse and reverse pointers
        while (curr != nullptr) {
            prec = curr->next;   // Store next node
            curr->next = prev;   // Reverse current link
            prev = curr;         // Move prev one step ahead
            curr = prec;         // Move curr one step ahead
        }

        // 'prev' becomes the new head of reversed list
        return prev;
    }
};
