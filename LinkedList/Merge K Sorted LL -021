/*
🧩 Problem: Merge K Sorted Linked Lists
-------------------------------------
Given an array of K linked lists, each linked list is sorted in ascending order.
Your task is to merge all the linked lists into one sorted linked list and return the head.

Example:
Input:
arr = [
  1 -> 4 -> 5,
  1 -> 3 -> 4,
  2 -> 6
]

Output:
1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6


⚙️ Approach: Divide and Conquer (Merge Sort Style)
-------------------------------------------------
1. Treat each linked list like an element in an array.
2. Recursively divide the array of linked lists into halves.
3. Merge pairs of linked lists using a standard 2-list merge.
4. Continue merging until only one sorted linked list remains.

🕒 Time Complexity:
O(N * K *  log K)
Where:
- N = total number of nodes across all lists
- K = number of linked lists


💾 Space Complexity:
O(1) auxiliary space (ignoring recursion stack)
All merges are done iteratively without extra DS.

This is the **optimal** approach for merging K sorted lists.
*/

class Node {
  public:
    int data;
    Node* next;

    Node(int x) {
        data = x;
        next = NULL;
    }
};

class Solution {
  public:

    // 🧠 Merge two sorted linked lists into one
    Node* merge(Node* head1, Node* head2) {
        // Dummy node to simplify logic
        Node* head = new Node(0);
        Node* tail = head;

        // Compare and attach nodes in sorted order
        while (head1 && head2) {
            if (head1->data <= head2->data) {
                tail->next = head1;
                head1 = head1->next;
            } else {
                tail->next = head2;
                head2 = head2->next;
            }
            tail = tail->next;
            tail->next = NULL;
        }

        // Attach remaining nodes
        if (head1)
            tail->next = head1;
        else
            tail->next = head2;

        // Skip dummy node
        Node* temp = head;
        head = head->next;
        delete temp;

        return head;
    }

    // 🔁 Recursive function to merge K linked lists using Divide & Conquer
    void MergeSort(vector<Node*>& arr, int start, int end) {
        if (start >= end)
            return;

        int mid = start + (end - start) / 2;

        // Recurse on both halves
        MergeSort(arr, start, mid);
        MergeSort(arr, mid + 1, end);

        // Merge the two sorted halves
        arr[start] = merge(arr[start], arr[mid + 1]);
    }

    // 🚀 Main function to merge all K linked lists
    Node* mergeKLists(vector<Node*>& arr) {
        if (arr.empty()) return NULL;
        MergeSort(arr, 0, arr.size() - 1);
        return arr[0];
    }
};
