/*
ğŸ§© Problem: Copy List with Random Pointer (LeetCode #138)

Given a linked list where each node has two pointers:
- `next`: points to the next node in the list.
- `random`: can point to any node in the list (or NULL).

Your task is to **create a deep copy** of the list â€” 
that means every node should be newly created and 
the `next` and `random` links should be preserved correctly 
for the cloned list.

---------------------------------------------------------------
ğŸ’¡ Example:
Input:
1 -> 2 -> 3
|    ^    
â†“    |    
3    1    

Output: (Deep copy)
1' -> 2' -> 3'
|     ^ 
â†“     |
3'    1'
---------------------------------------------------------------
ğŸ” Approach:

Weâ€™ll use a 3-step **O(N)** time, **O(1)** extra space method:

1ï¸âƒ£ **Duplicate each node and insert it after the original one.**
   So original list like:
   A â†’ B â†’ C
   becomes:
   A â†’ A' â†’ B â†’ B' â†’ C â†’ C'

2ï¸âƒ£ **Assign random pointers** for the copied nodes:
   If original node A has random pointer to B,
   then A' (copy) will have random pointing to B'.

3ï¸âƒ£ **Detach the new copied list** from the original list.

---------------------------------------------------------------
ğŸ§® Complexity:
Time  = O(N)   â†’ traversing the list 3 times.
Space = O(1)   â†’ no extra hash map or list used.

*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        // âœ… Edge case: empty list
        if (head == NULL)
            return NULL;

        // ğŸª„ Step 1: Insert cloned nodes after each original node
        Node* curr = head;
        while (curr) {
            Node* copy = new Node(curr->val); // clone node
            copy->next = curr->next;          // link clone to next original
            curr->next = copy;                // link original to clone
            curr = copy->next;                // move to next original
        }

        // ğŸ¯ Step 2: Set random pointers for cloned nodes
        Node* original = head;
        while (original) {
            if (original->random)
                original->next->random = original->random->next;
            original = original->next->next; // skip to next original
        }

        // âœ‚ï¸ Step 3: Detach the cloned list from the original list
        Node* newHead = head->next; // head of cloned list
        Node* clone = newHead;
        original = head;

        while (clone && original) {
            original->next = clone->next;             // restore original next
            if (clone->next)
                clone->next = clone->next->next;      // link clone to next clone
            original = original->next;
            clone = clone->next;
        }

        // âœ… Return deep copied list head
        return newHead;
    }
};
