/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

/**
 * @brief Rotates a linked list to the right by k positions.
 * 
 * This function takes the head of a singly linked list and an integer k,
 * and rotates the list to the right by k places. The rotation means that 
 * the last k nodes of the list are moved to the front in the same order.
 * 
 * Example:
 * Input: head = [1,2,3,4,5], k = 2
 * Output: [4,5,1,2,3]
 * 
 * Approach:
 * 1. Handle edge cases — if the list is empty, has one node, or k is 0, 
 *    no rotation is needed.
 * 2. Count the total number of nodes in the linked list.
 * 3. Normalize k by taking k % count (since rotating count times 
 *    gives the original list).
 * 4. Find the node just before the new head (at position count - k - 1).
 * 5. Break the list at that point and make the new head point to the 
 *    next node.
 * 6. Traverse to the end of the rotated list and connect it to the 
 *    original head.
 * 
 * Time Complexity: O(n) — traverses the list twice (counting + rearranging)
 * Space Complexity: O(1) — uses constant extra space
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        // Edge cases: no rotation needed
        if (k == 0 || !head || !head->next)
            return head;

        // Step 1: Count the number of nodes in the list
        int count = 1;
        ListNode* temp = head;
        while (temp->next) {
            count++;
            temp = temp->next;
        }

        // Step 2: Normalize k to handle cases where k > count
        k %= count;
        if (k == 0)
            return head;  // No rotation needed

        // Step 3: Find the node before the new head (at position count - k - 1)
        temp = head;
        for (int i = 0; i < count - k - 1; i++)
            temp = temp->next;

        // Step 4: The next node becomes the new head
        ListNode* newHead = temp->next;
        temp->next = nullptr;  // Break the link to form the new tail

        // Step 5: Move to the end of the new list to connect it with the old head
        ListNode* tail = newHead;
        while (tail->next)
            tail = tail->next;
        tail->next = head;

        // Step 6: Return the new head
        return newHead;
    }
};
