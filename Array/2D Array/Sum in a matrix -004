/*
Problem: Matrix Sum (LeetCode 2679)

You are given a 2D integer matrix 'nums' of size m x n.
- First, in each row, you can reorder the elements however you want.
- Then, for each column, find the maximum element among all rows in that column.
- Add up these maximums for all columns and return the total sum.

Example:
--------
Input:
nums = [
    [7, 2, 1],
    [6, 4, 2],
    [6, 5, 3],
    [3, 2, 1]
]

Step 1: Sort each row in ascending order:
[
    [1, 2, 7],
    [2, 4, 6],
    [3, 5, 6],
    [1, 2, 3]
]

Step 2: For each column, pick the maximum:
Column 0: max(1, 2, 3, 1) = 3
Column 1: max(2, 4, 5, 2) = 5
Column 2: max(7, 6, 6, 3) = 7

Step 3: Sum = 3 + 5 + 7 = 15

Output: 15

Constraints:
------------
- m == nums.length
- n == nums[i].length
- 1 <= m, n <= 50
- 1 <= nums[i][j] <= 100
*/

class Solution {
public:
    int matrixSum(vector<vector<int>>& nums) {
        int ans = 0;
        int row = nums.size();
        int col = nums[0].size();

        /*
         Step 1: Sort each row so that the largest numbers 
         end up in the rightmost positions.
         This way, when we take column max later, we are
         effectively picking the "strongest" card in each round.
        */
        for (int i = 0; i < row; i++)
            sort(nums[i].begin(), nums[i].end());

        /*
         Step 2: Iterate column by column, 
         find the max element in that column across all rows,
         and add it to the answer.
        */
        for (int i = 0; i < col; i++) {
            int maxi = INT_MIN;
            for (int j = 0; j < row; j++) {
                maxi = max(nums[j][i], maxi);
            }
            ans += maxi;
        }

        return ans;
    }
};

/*
Time Complexity:
----------------
O(m * n log n) — We sort each row (n log n) and do a column-wise max search (m * n).

Space Complexity:
-----------------
O(1) — Sorting is done in-place.
*/
