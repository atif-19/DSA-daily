class Solution {
public:
    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& grid) {
        int n = grid.size(); // size of the grid (n x n)
        vector<int> ans(2); // ans[0] = repeated number, ans[1] = missing number

        // STEP 1: Decrease each element by 1 to make them zero-indexed
        // This helps us map values directly to positions without off-by-one errors
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] -= 1;
            }
        }

        // STEP 2: Mark frequencies directly in the grid
        // Using modulo and integer division tricks to store counts without extra space
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // Find the original value (ignoring the extra counts added)
                int index = grid[i][j] % (n * n);

                // Map this 1D index back to 2D position in the grid
                int row = index / n;
                int col = index % n;

                // Add n*n to that position to "mark" a visit
                grid[row][col] += n * n;
            }
        }

        // STEP 3: Detect missing and repeating numbers
        // If a cell is visited twice → repeated number
        // If a cell is never visited → missing number
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int index = i * n + j;
                int freq = grid[i][j] / (n * n);

                if (freq == 0) // never visited → missing number
                    ans[1] = index + 1;
                else if (freq == 2) // visited twice → repeated number
                    ans[0] = index + 1;
            }
        }

        return ans;
    }
};
