/*
---------------------------------------
ğŸ“Œ Problem: Roman to Integer
---------------------------------------
ğŸ“ Statement:
Given a Roman numeral string, convert it into its integer representation.

Roman numeral rules:
- I(1), V(5), X(10), L(50), C(100), D(500), M(1000)
- If a smaller numeral comes before a larger one, subtract it. (e.g., IV = 4)
- Otherwise, add its value. (e.g., VI = 6)

Example:
Input:  s = "MCMXCIV"
Output: 1994
Explanation:
    M  (1000) â†’ add
    CM (900)  â†’ subtract C (100) from M (1000)
    XC (90)   â†’ subtract X (10) from C (100)
    IV (4)    â†’ subtract I (1) from V (5)

---------------------------------------
ğŸ’¡ Approach:
---------------------------------------
1. Store the value of each Roman numeral in an unordered_map for O(1) access.
2. Traverse the string from left to right:
    - If the current numeral is smaller than the next one, subtract its value.
    - Else, add its value.
3. Return the final sum.

This approach directly implements the Roman numeral rules in a single pass.

---------------------------------------
â± Complexity:
---------------------------------------
- Time:  O(n) â†’ Single pass through the string.
- Space: O(1) â†’ Fixed size map of 7 entries.

---------------------------------------
ğŸ¯ Flashcards (for revision):
---------------------------------------
Q: How do you decide whether to subtract or add a Roman numeral?
A: If its value is less than the next numeralâ€™s value â†’ subtract, else add.

Q: Why is unordered_map used?
A: For O(1) lookup of numeral values.

Q: What's the largest value a Roman numeral can represent here?
A: M (1000) â€” but combination rules allow much larger numbers.

---------------------------------------
*/

class Solution {
public:
    int romanToInt(string s) {
        // Roman numeral to integer mapping
        unordered_map<char,int> val = {
            {'I',1}, {'V',5}, {'X',10}, {'L',50},
            {'C',100}, {'D',500}, {'M',1000}
        };

        int ans = 0;

        for (int i = 0; i < s.size(); i++) {
            // If current value < next value â†’ subtract
            if (i + 1 < s.size() && val[s[i]] < val[s[i+1]])
                ans -= val[s[i]];
            else
                ans += val[s[i]];
        }

        return ans;
    }
};
